# ui/main_window.py

import sys
import re
from pathlib import Path
from typing import Optional, List, Dict, Tuple, Any, Union
from datetime import datetime

from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QSplitter,
    QGraphicsScene, QMenuBar, QToolBar, QFileDialog, QMessageBox, 
    QPushButton, QComboBox, QProgressBar, QCheckBox, QSlider, QLabel, QColorDialog, QSpinBox,
    QDialog, QListWidget, QListWidgetItem
)
from PySide6.QtCore import Qt, QRectF, QPointF, QThreadPool, Signal, Slot, QSettings
from PySide6.QtGui import (
    QPainter, QPixmap, QImage, QColor, QPen, QBrush, QPainterPath, 
    QAction, QKeySequence
)

# ÂØºÂÖ•Ëá™ÂÆö‰πâÊ®°Âùó
from utils.constants import (
    APP_TITLE, FILE_DIALOG_FILTER, DEFAULT_WINDOW_SIZE, DEFAULT_WINDOW_POSITION,
    DEFAULT_OCR_LANGUAGES, PDF_QUALITY_OPTIONS, OCR_TEXT_TYPE_COLORS,
    OCR_TYPE_TO_STYLE, STYLE_NAME_MAP, STYLE_NAME_REVERSE_MAP,
    OCR_FILTER_OPTIONS, OCR_FILTER_TYPE_MAP, UI_COLORS, SUPPORTED_IMAGE_FORMATS,
    SUPPORTED_PDF_FORMATS, SUPPORTED_DXF_FORMATS,
    BUBBLE_SIZE_MIN_PERCENT, BUBBLE_SIZE_MAX_PERCENT, BUBBLE_SIZE_DEFAULT_PERCENT, BUBBLE_SIZE_STEP,
    BUBBLE_REORDER_GRID_SIZE
)
from utils.dependencies import HAS_OCR_SUPPORT, HAS_GPU_SUPPORT, HAS_PADDLE_OCR, get_requirements_message

# Âè™ÂØºÂÖ•PaddleOCRÂ∑•‰ΩúÂô®
if HAS_PADDLE_OCR:
    from core.paddle_ocr_worker import PaddleOCRWorker
from core.annotation_item import BubbleAnnotationItem
from core.file_loader import FileLoader

from ui.graphics_view import GraphicsView
from ui.annotation_list import AnnotationTable
from ui.property_editor import PropertyEditor

# ÁßªÈô§OCRÊ°ÜÈ°πÂØºÂÖ•

try:
    import openpyxl
    from openpyxl.styles import Font, Alignment
    import pandas as pd
    HAS_EXCEL_SUPPORT = True
except ImportError:
    HAS_EXCEL_SUPPORT = False

if HAS_OCR_SUPPORT:
    import numpy as np

# ÂØºÂÖ•Êàë‰ª¨ÁöÑÂëΩ‰ª§Á±ª
# from core.undo_commands import (
#     AddAnnotationCommand, DeleteAnnotationCommand, MoveAnnotationCommand,
#     EditAnnotationTextCommand, EditAnnotationStyleCommand, EditAnnotationShapeCommand,
#     EditAnnotationColorCommand, EditAnnotationSizeCommand, ClearAnnotationsCommand
# )

class MainWindow(QMainWindow):
    """
    ‰∏ªÁ™óÂè£Á±ª
    """
    def __init__(self):
        super().__init__()
        self.setWindowTitle(APP_TITLE)
        self.annotations: List[BubbleAnnotationItem] = []
        self.annotation_counter = 0
        self.current_file_path: Optional[str] = None
        self.current_pixmap: Optional[QPixmap] = None
        self.ocr_results: List[dict] = []
        self.thread_pool = QThreadPool()
        self.current_annotation: Optional[BubbleAnnotationItem] = None
        
        self.next_annotation_color: Optional[QColor] = None
        self.next_annotation_size: int = -1  # -1Ë°®Á§∫Ëá™Âä®Â§ßÂ∞è
        self.next_annotation_scale: float = 1.0  # ÈªòËÆ§ÊØî‰æã‰∏∫100%
        
        self.masked_regions: List[QRectF] = []
        self.is_selecting_mask = False
        
        self.setup_ui()
        self.setup_menu_bar()
        self.setup_toolbar()
        self.setup_connections()
        
        self.resize(*DEFAULT_WINDOW_SIZE)
        
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Â∞±Áª™", 2000)
        
    def setup_ui(self):
        self.setGeometry(*DEFAULT_WINDOW_POSITION, *DEFAULT_WINDOW_SIZE)
        self.setStyleSheet(f"""
            QMainWindow {{ background-color: {UI_COLORS["background"]}; }}
            QSplitter::handle {{ background-color: {UI_COLORS["border"]}; width: 3px; height: 3px; }}
            QSplitter::handle:hover {{ background-color: #adb5bd; }}
            QLabel {{ font-weight: bold; color: {UI_COLORS["text"]}; padding: 5px; background-color: #e9ecef; border-bottom: 1px solid {UI_COLORS["border"]}; }}
            QWidget {{ font-family: "Microsoft YaHei", "Arial", sans-serif; color: {UI_COLORS["text"]}; background-color: {UI_COLORS["white"]}; }}
            QPushButton {{ background-color: {UI_COLORS["white"]}; border: 1px solid #ced4da; border-radius: 4px; padding: 8px 15px; min-height: 20px; color: {UI_COLORS["text_secondary"]}; }}
            QPushButton:hover {{ background-color: {UI_COLORS["background"]}; border-color: #6c757d; color: {UI_COLORS["text"]}; }}
            QPushButton:pressed {{ background-color: #e9ecef; }}
            QPushButton:disabled {{ background-color: #e9ecef; color: #6c757d; border-color: {UI_COLORS["border"]}; }}
            QComboBox {{ background-color: {UI_COLORS["white"]}; border: 1px solid #ced4da; border-radius: 3px; padding: 4px 8px; color: {UI_COLORS["text_secondary"]}; }}
            QComboBox:hover {{ border-color: #6c757d; }}
            QCheckBox {{ color: {UI_COLORS["text_secondary"]}; }}
            QSlider::groove:horizontal {{ background-color: {UI_COLORS["border"]}; height: 8px; border-radius: 4px; }}
            QSlider::handle:horizontal {{ background-color: #6c757d; border: 1px solid {UI_COLORS["text_secondary"]}; width: 18px; border-radius: 9px; margin: -5px 0; }}
            QSlider::handle:horizontal:hover {{ background-color: {UI_COLORS["text_secondary"]}; }}
        """)
        central_widget = QWidget(); self.setCentralWidget(central_widget)
        layout = QHBoxLayout(central_widget); layout.setContentsMargins(5, 5, 5, 5); layout.setSpacing(5)
        main_splitter = QSplitter(Qt.Horizontal); layout.addWidget(main_splitter)
        left_splitter = QSplitter(Qt.Vertical)
        graphics_panel = QWidget(); graphics_layout = QVBoxLayout(graphics_panel); graphics_layout.setContentsMargins(0, 0, 0, 0); graphics_layout.setSpacing(0)
        graphics_title = QLabel("ÂõæÁ∫∏ËßÜÂõæ & OCRËØÜÂà´"); graphics_title.setStyleSheet(f"QLabel {{ background-color: {UI_COLORS['primary']}; color: white; font-weight: bold; padding: 8px; margin: 0px; border: none; }}"); graphics_layout.addWidget(graphics_title)
        self.setup_compact_ocr_panel(graphics_layout)
        self.graphics_view = GraphicsView(); self.graphics_scene = QGraphicsScene(); self.graphics_view.setScene(self.graphics_scene); graphics_layout.addWidget(self.graphics_view)
        
        # --- ‰øÆÊîπÔºöÁßªÈô§ÊóßÁöÑÂÆ°Ê†∏ÊåâÈíÆÂ∏ÉÂ±Ä ---
        annotation_panel = QWidget()
        annotation_layout = QVBoxLayout(annotation_panel)
        annotation_layout.setContentsMargins(0, 0, 0, 0); annotation_layout.setSpacing(0)
        annotation_title = QLabel("Ê†áÊ≥®ÂàóË°®"); annotation_title.setStyleSheet(f"QLabel {{ background-color: {UI_COLORS['secondary']}; color: white; font-weight: bold; padding: 8px; margin: 0px; border: none; }}"); annotation_layout.addWidget(annotation_title)
        self.annotation_table = AnnotationTable(); annotation_layout.addWidget(self.annotation_table)
        
        left_splitter.addWidget(graphics_panel); left_splitter.addWidget(annotation_panel)
        left_splitter.setStretchFactor(0, 3); left_splitter.setStretchFactor(1, 1)
        
        right_panel = QWidget(); right_layout = QVBoxLayout(right_panel); right_layout.setContentsMargins(0, 0, 0, 0); right_layout.setSpacing(0)
        property_title = QLabel("Â±ûÊÄßÁºñËæëÂô®"); property_title.setStyleSheet(f"QLabel {{ background-color: {UI_COLORS['success']}; color: white; font-weight: bold; padding: 8px; margin: 0px; border: none; }}"); right_layout.addWidget(property_title)
        self.property_editor = PropertyEditor(self); right_layout.addWidget(self.property_editor)
        main_splitter.addWidget(left_splitter); main_splitter.addWidget(right_panel)
        main_splitter.setStretchFactor(0, 3); main_splitter.setStretchFactor(1, 1)

    def setup_compact_ocr_panel(self, parent_layout):
        ocr_widget = QWidget(); ocr_widget.setMaximumHeight(200); ocr_layout = QVBoxLayout(ocr_widget); ocr_layout.setContentsMargins(5, 5, 5, 5); ocr_layout.setSpacing(3)
        row1_layout = QHBoxLayout(); row1_layout.addWidget(QLabel("ËØ≠Ë®Ä:")); self.language_combo = QComboBox(); self.language_combo.addItems(list(DEFAULT_OCR_LANGUAGES.keys())); self.language_combo.setCurrentText("‰∏≠Êñá+Ëã±Êñá"); row1_layout.addWidget(self.language_combo)
        row1_layout.addWidget(QLabel("ÁΩÆ‰ø°Â∫¶:")); self.confidence_slider = QSlider(Qt.Horizontal); self.confidence_slider.setRange(10, 90); self.confidence_slider.setValue(30); self.confidence_slider.setMaximumWidth(80); self.confidence_label = QLabel("0.30"); self.confidence_label.setMinimumWidth(40); row1_layout.addWidget(self.confidence_slider); row1_layout.addWidget(self.confidence_label); ocr_layout.addLayout(row1_layout)
        row2_layout = QHBoxLayout()
        self.enhance_contrast_cb = QCheckBox("Â¢ûÂº∫ÂØπÊØîÂ∫¶"); self.enhance_contrast_cb.setChecked(True); row2_layout.addWidget(self.enhance_contrast_cb)
        self.denoise_cb = QCheckBox("ÈôçÂô™"); self.denoise_cb.setChecked(True); row2_layout.addWidget(self.denoise_cb)
        self.gpu_checkbox = QCheckBox("GPU"); self.gpu_checkbox.setChecked(HAS_GPU_SUPPORT); self.gpu_checkbox.setEnabled(HAS_GPU_SUPPORT); row2_layout.addWidget(self.gpu_checkbox)
        self.cpu_checkbox = QCheckBox("CPU"); self.cpu_checkbox.setChecked(not HAS_GPU_SUPPORT); row2_layout.addWidget(self.cpu_checkbox)
        row2_layout.addWidget(QLabel("Á∫øÁ®ãÊï∞:"))
        self.threads_spinbox = QSpinBox()
        self.threads_spinbox.setMinimum(1)
        self.threads_spinbox.setMaximum(32)
        self.threads_spinbox.setValue(8)  # ÈªòËÆ§8Á∫øÁ®ã
        self.threads_spinbox.setToolTip("CPUÊ®°Âºè‰∏ã‰ΩøÁî®ÁöÑÁ∫øÁ®ãÊï∞")
        self.threads_spinbox.setEnabled(not HAS_GPU_SUPPORT)  # ÂàùÂßãÁä∂ÊÄÅÊ†πÊçÆCPUÈÄâÊã©Ê°ÜÁä∂ÊÄÅ
        row2_layout.addWidget(self.threads_spinbox)
        row2_layout.addStretch(); ocr_layout.addLayout(row2_layout)
        row3_layout = QHBoxLayout(); self.ocr_button = QPushButton("üîç ÂºÄÂßãOCRËØÜÂà´" if HAS_OCR_SUPPORT else "‚ùå OCR‰∏çÂèØÁî®");
        if not HAS_OCR_SUPPORT: self.ocr_button.setEnabled(False); self.ocr_button.setToolTip("ËØ∑ÂÆâË£ÖÂÆåÊï¥‰æùËµñÂåÖ‰ª•ÂêØÁî®OCRÂäüËÉΩ")
        self.ocr_button.setStyleSheet(f"""QPushButton {{ background-color: {UI_COLORS["primary"]}; color: white; font-weight: bold; border: none; min-height: 25px; }} QPushButton:hover {{ background-color: {UI_COLORS["secondary"]}; }} QPushButton:disabled {{ background-color: #cccccc; color: #666666; }}""")
        row3_layout.addWidget(self.ocr_button); self.create_all_btn = QPushButton("ÂÖ®ÈÉ®Ê†áÊ≥®"); self.create_all_btn.setMaximumWidth(80); row3_layout.addWidget(self.create_all_btn); self.clear_ocr_btn = QPushButton("Ê∏ÖÈô§OCR"); self.clear_ocr_btn.setMaximumWidth(80); row3_layout.addWidget(self.clear_ocr_btn); ocr_layout.addLayout(row3_layout)
        self.progress_bar = QProgressBar(); self.progress_bar.setVisible(False); self.progress_bar.setMaximumHeight(15); ocr_layout.addWidget(self.progress_bar); self.ocr_stats_label = QLabel("ËØÜÂà´ÁªìÊûú: 0‰∏™ÊñáÊú¨"); self.ocr_stats_label.setStyleSheet("QLabel { background-color: transparent; border: none; padding: 4px; color: #6c757d; font-size: 11px; }"); ocr_layout.addWidget(self.ocr_stats_label)
        filter_layout = QHBoxLayout(); filter_layout.addWidget(QLabel("Á≠õÈÄâ:")); self.filter_combo = QComboBox(); self.filter_combo.addItems(OCR_FILTER_OPTIONS); filter_layout.addWidget(self.filter_combo); filter_layout.addStretch(); ocr_layout.addLayout(filter_layout)
        parent_layout.addWidget(ocr_widget)

    def setup_menu_bar(self):
        menubar = self.menuBar()
        file_menu = menubar.addMenu("Êñá‰ª∂")
        open_action = QAction("ÊâìÂºÄ...", self); open_action.setShortcut("Ctrl+O"); open_action.triggered.connect(self.open_file); file_menu.addAction(open_action)
        
        # Ê∑ªÂä†PDFËΩ¨Êç¢ÂäüËÉΩ
        convert_pdf_action = QAction("PDFËΩ¨Êç¢‰∏∫PNG...", self); convert_pdf_action.triggered.connect(self.convert_pdf_to_images); file_menu.addAction(convert_pdf_action)
        
        if HAS_EXCEL_SUPPORT:
            export_action = QAction("ÂØºÂá∫‰∏∫Excel...", self); export_action.setShortcut("Ctrl+E"); export_action.triggered.connect(self.export_to_excel); file_menu.addAction(export_action)
        file_menu.addSeparator()
        
        # --- Êñ∞Â¢ûÔºöÂàõÂª∫ÂÖ®Â±ÄÂø´Êç∑ÈîÆÂä®‰Ωú ---
        self.audit_action = QAction("ÂÆ°Ê†∏", self)
        self.audit_action.setShortcut(QKeySequence("F2"))
        self.audit_action.triggered.connect(self.audit_current_annotation)
        self.addAction(self.audit_action) # Ê∑ªÂä†Âà∞‰∏ªÁ™óÂè£Ôºå‰ΩøÂÖ∂ÂÖ®Â±ÄÊúâÊïà
        # -----------------------------

        exit_action = QAction("ÈÄÄÂá∫", self); exit_action.setShortcut("Ctrl+Q"); exit_action.triggered.connect(self.close); file_menu.addAction(exit_action)
    
    def setup_toolbar(self):
        toolbar = self.addToolBar("‰∏ªÂ∑•ÂÖ∑Ê†è")
        open_action = QAction("ÊâìÂºÄÊñá‰ª∂", self); open_action.triggered.connect(self.open_file); toolbar.addAction(open_action)
        if HAS_EXCEL_SUPPORT:
            export_btn = QPushButton("ÂØºÂá∫Excel"); export_btn.setToolTip("Â∞ÜÂΩìÂâçÊ†áÊ≥®ÂàóË°®ÂØºÂá∫‰∏∫ExcelÊñá‰ª∂"); export_btn.clicked.connect(self.export_to_excel); toolbar.addWidget(export_btn)
        
        toolbar.addSeparator()
        toolbar.addWidget(QLabel("PDFË¥®Èáè:")); self.pdf_quality_combo = QComboBox(); self.pdf_quality_combo.addItems(list(PDF_QUALITY_OPTIONS.keys())); self.pdf_quality_combo.setCurrentText("È´òÊ∏Ö (4x)"); self.pdf_quality_combo.setToolTip("Ê∏≤ÊüìPDFÊó∂ÁöÑÊ∏ÖÊô∞Â∫¶ÔºåË∂äÈ´òË∂äÊ∏ÖÊô∞‰ΩÜÂä†ËΩΩË∂äÊÖ¢"); toolbar.addWidget(self.pdf_quality_combo)
        toolbar.addSeparator()
        ai_recognize_action = QAction("AIËØÜÂà´", self); ai_recognize_action.triggered.connect(self.simulate_ai_recognition); toolbar.addAction(ai_recognize_action)
        self.area_select_action = QAction("Âå∫ÂüüOCRÊ†áÊ≥®", self); self.area_select_action.setCheckable(True); self.area_select_action.setShortcut("Q"); self.area_select_action.setStatusTip("ÊøÄÊ¥ªÂêéÔºåÂú®ÂõæÁ∫∏‰∏äÊãñÊãΩÈº†Ê†á‰ª•Ê°ÜÈÄâÂå∫ÂüüËøõË°åOCRËØÜÂà´"); self.area_select_action.toggled.connect(self.toggle_area_selection); toolbar.addAction(self.area_select_action)
        self.mask_select_action = QAction("üö´ Â±èËîΩÂå∫Âüü", self); self.mask_select_action.setCheckable(True); self.mask_select_action.setStatusTip("ÊøÄÊ¥ªÂêéÔºåÂú®ÂõæÁ∫∏‰∏äÊãñÊãΩÈº†Ê†á‰ª•ÈÄâÊã©Ë¶ÅÂøΩÁï•OCRÁöÑÂå∫Âüü"); self.mask_select_action.toggled.connect(self.toggle_mask_selection); toolbar.addAction(self.mask_select_action)
        toolbar.addSeparator()
        # Ê∑ªÂä†ÈáçÊñ∞ÊéíÂ∫èÊåâÈíÆ
        reorder_action = QAction("üîÑ ÈáçÊñ∞ÊéíÂ∫è", self)
        reorder_action.setToolTip("ÈáçÊñ∞ÁªôÊâÄÊúâÊ∞îÊ≥°Ê†áÊ≥®ÊéíÂ∫èÁºñÂè∑(‰ªéÂ∑¶Âà∞Âè≥Ôºå‰ªé‰∏äÂà∞‰∏ã)")
        reorder_action.triggered.connect(self.reorder_annotations)
        toolbar.addAction(reorder_action)
        clear_action = QAction("Ê∏ÖÈô§Ê†áÊ≥®", self); clear_action.triggered.connect(self.clear_annotations); toolbar.addAction(clear_action)
        toolbar.addSeparator()
        toolbar.addWidget(QLabel("Ê∞îÊ≥°Â§ßÂ∞è:")); 
        # ‰ΩøÁî®Â∏∏ÈáèÂÆö‰πâÊØî‰æãÊªëÂùóÂèÇÊï∞
        self.size_slider = QSlider(Qt.Horizontal)
        # ‰ΩøÁî®Â∏∏ÈáèÂÆö‰πâÔºå‰ΩÜÂº∫Âà∂ËΩ¨Êç¢‰∏∫Êï¥Êï∞Á±ªÂûã
        self.size_slider.setRange(int(BUBBLE_SIZE_MIN_PERCENT), int(BUBBLE_SIZE_MAX_PERCENT))
        self.size_slider.setSingleStep(int(BUBBLE_SIZE_STEP))
        self.size_slider.setPageStep(int(BUBBLE_SIZE_STEP * 2))
        self.size_slider.setTickPosition(QSlider.TicksBelow)
        self.size_slider.setTickInterval(int(BUBBLE_SIZE_STEP*2))
        # ËÆæÁΩÆÈªòËÆ§ÂÄº
        self.size_slider.setValue(int(BUBBLE_SIZE_DEFAULT_PERCENT))
        # Ë∞ÉËØï‰ø°ÊÅØ
        print(f"ÊªëÂùóÂàùÂßãËÆæÁΩÆ: ËåÉÂõ¥{BUBBLE_SIZE_MIN_PERCENT}-{BUBBLE_SIZE_MAX_PERCENT}, Ê≠•Èïø{BUBBLE_SIZE_STEP}, ÂΩìÂâçÂÄº{BUBBLE_SIZE_DEFAULT_PERCENT}")
        self.size_slider.setFixedWidth(120)  # Â¢ûÂä†ÂÆΩÂ∫¶Ôºå‰ΩøÊªëÂùóÊõ¥ÂÆπÊòìÊãñÂä®
        # ÊòæÁ§∫ÊØî‰æãËÄå‰∏çÊòØÁªùÂØπÂÄº
        self.size_label = QLabel(f"{BUBBLE_SIZE_DEFAULT_PERCENT}%")
        self.size_label.setFixedWidth(40)
        toolbar.addWidget(self.size_slider)
        toolbar.addWidget(self.size_label)
        toolbar.addSeparator()
        self.color_button = QPushButton("È¢úËâ≤"); self.color_button.setToolTip("ÈÄâÊã©‰∏ã‰∏Ä‰∏™Ê†áÊ≥®ÁöÑÈ¢úËâ≤ÔºåÊàñ‰øÆÊîπÂΩìÂâçÈÄâ‰∏≠Ê†áÊ≥®ÁöÑÈ¢úËâ≤"); self.color_button.clicked.connect(self.select_annotation_color); toolbar.addWidget(self.color_button)
        toolbar.addWidget(QLabel("ÂΩ¢Áä∂:")); self.shape_combo = QComboBox(); self.shape_combo.addItems(["Á©∫ÂøÉÂúÜ", "ÂÆûÂøÉÂúÜ", "‰∫îËßíÊòü", "‰∏âËßíÂΩ¢"]); toolbar.addWidget(self.shape_combo)
        toolbar.addWidget(QLabel("Âø´ÈÄüÊ†∑Âºè:")); self.style_combo = QComboBox(); self.style_combo.addItems(["Ëá™ÂÆö‰πâ"] + list(STYLE_NAME_MAP.values())); toolbar.addWidget(self.style_combo)
    
    def setup_connections(self):
        self.annotation_table.annotation_selected.connect(self.select_annotation_by_id)
        self.graphics_view.area_selected.connect(self.handle_area_selection)
        self.size_slider.valueChanged.connect(self.change_annotation_size)
        self.shape_combo.currentTextChanged.connect(self.change_current_annotation_shape)
        self.style_combo.currentTextChanged.connect(self.change_current_annotation_style)
        self.confidence_slider.valueChanged.connect(lambda v: self.confidence_label.setText(f"{v/100:.2f}"))
        self.ocr_button.clicked.connect(self.start_ocr_recognition)
        self.create_all_btn.clicked.connect(self.create_annotations_from_ocr)
        self.clear_ocr_btn.clicked.connect(self.clear_ocr_results)
        self.filter_combo.currentTextChanged.connect(self.filter_ocr_results)
        # --- Êñ∞Â¢ûËøûÊé•ÔºöËøûÊé•Êñ∞ÊåâÈíÆÁöÑ‰ø°Âè∑ ---
        self.property_editor.audit_requested.connect(self.audit_current_annotation)
        self.property_editor.delete_requested.connect(self.delete_current_annotation)
        
        # GPUÂíåCPUÈÄâÈ°π‰∫íÊñ•
        self.gpu_checkbox.toggled.connect(self.on_gpu_checkbox_toggled)
        self.cpu_checkbox.toggled.connect(self.on_cpu_checkbox_toggled)

    def audit_current_annotation(self):
        if not self.current_annotation:
            # Â¶ÇÊûúÊ≤°ÊúâÈÄâ‰∏≠ÁöÑÔºåÂ∞ùËØïÈÄâ‰∏≠Á¨¨‰∏Ä‰∏™Êú™ÂÆ°Ê†∏ÁöÑ
            sorted_annotations = sorted(self.annotations, key=lambda ann: ann.annotation_id)
            first_unaudited = next((ann for ann in sorted_annotations if not ann.is_audited), None)
            if first_unaudited:
                self.select_annotation_by_id(first_unaudited.annotation_id)
            else:
                QMessageBox.warning(self, "ÊèêÁ§∫", "Ê≤°ÊúâÈúÄË¶ÅÂÆ°Ê†∏ÁöÑÊ†áÊ≥®„ÄÇ")
            return

        # 1. ÂÆ°Ê†∏ÂΩìÂâçÈ°π
        self.current_annotation.set_audited(True)

        # 2. ÂØªÊâæ‰∏ã‰∏Ä‰∏™Êú™ÂÆ°Ê†∏È°π
        sorted_annotations = sorted(self.annotations, key=lambda ann: ann.annotation_id)
        current_index = -1
        for i, ann in enumerate(sorted_annotations):
            if ann.annotation_id == self.current_annotation.annotation_id:
                current_index = i
                break

        next_annotation_to_select = None
        
        # ‰ªéÂΩìÂâçÈ°π‰πãÂêéÂºÄÂßãÂØªÊâæ
        if current_index != -1:
            for i in range(current_index + 1, len(sorted_annotations)):
                if not sorted_annotations[i].is_audited:
                    next_annotation_to_select = sorted_annotations[i]
                    break
        
        # Â¶ÇÊûúÂêéÈù¢Ê≤°ÊúâÔºåÂ∞±‰ªéÂ§¥ÂºÄÂßãÊâæ
        if not next_annotation_to_select:
            for ann in sorted_annotations:
                if not ann.is_audited:
                    next_annotation_to_select = ann
                    break
        
        # 3. Ë∑≥ËΩ¨
        if next_annotation_to_select:
            self.select_annotation_by_id(next_annotation_to_select.annotation_id)
        else:
            QMessageBox.information(self, "ÂÆ°Ê†∏ÂÆåÊàê", "ÊâÄÊúâÊ†áÊ≥®ÂùáÂ∑≤ÂÆ°Ê†∏ÔºÅ")

    def export_to_excel(self):
        if not HAS_EXCEL_SUPPORT:
            QMessageBox.warning(self, "ÂäüËÉΩÁº∫Â§±", "Áº∫Â∞ë 'openpyxl' Â∫ìÔºåÊó†Ê≥ïÂØºÂá∫Excel„ÄÇ\nËØ∑ËøêË°å: pip install openpyxl"); return
        if not self.annotations:
            QMessageBox.information(self, "ÊèêÁ§∫", "Ê†áÊ≥®ÂàóË°®‰∏∫Á©∫ÔºåÊó†ÈúÄÂØºÂá∫„ÄÇ"); return
        
        default_filename = f"{Path(self.current_file_path).stem}_Ê†áÊ≥®ÂàóË°®.xlsx" if self.current_file_path else "Ê†áÊ≥®ÂàóË°®.xlsx"
        file_path, _ = QFileDialog.getSaveFileName(self, "ÂØºÂá∫‰∏∫ExcelÊñá‰ª∂", default_filename, "Excel Êñá‰ª∂ (*.xlsx)")
        
        if not file_path: return
        
        try:
            wb = openpyxl.Workbook(); ws = wb.active; ws.title = "Ê†áÊ≥®Êï∞ÊçÆ"
            headers = [self.annotation_table.horizontalHeaderItem(i).text() for i in range(self.annotation_table.columnCount())]
            ws.append(headers)
            
            header_font = Font(bold=True)
            for cell in ws[1]: 
                cell.font = header_font
                cell.alignment = Alignment(horizontal='center', vertical='center')
            
            for ann in self.annotations:
                row_data = [
                    str(ann.annotation_id),
                    ann.dimension_type,
                    ann.dimension,
                    ann.upper_tolerance,
                    ann.lower_tolerance,
                    "ÊòØ" if ann.is_audited else "Âê¶"
                ]
                ws.append(row_data)

            for col_idx, column in enumerate(ws.columns):
                max_length = 0
                column_letter = openpyxl.utils.get_column_letter(col_idx + 1)
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = max(max_length + 2, len(headers[col_idx]) + 2)
                ws.column_dimensions[column_letter].width = adjusted_width if adjusted_width < 50 else 50
            ws.column_dimensions[openpyxl.utils.get_column_letter(6)].width = 10


            wb.save(file_path)
            QMessageBox.information(self, "ÂØºÂá∫ÊàêÂäü", f"Ê†áÊ≥®ÂàóË°®Â∑≤ÊàêÂäüÂØºÂá∫Âà∞:\n{file_path}")
            self.status_bar.showMessage(f"ÊàêÂäüÂØºÂá∫Âà∞ {Path(file_path).name}", 5000)
        except Exception as e:
            QMessageBox.critical(self, "ÂØºÂá∫Â§±Ë¥•", f"ÂØºÂá∫Âà∞ExcelÊó∂ÂèëÁîüÈîôËØØ:\n{e}")
            self.status_bar.showMessage("ÂØºÂá∫Â§±Ë¥•", 3000)

    def open_file(self):
        file_dialog = QFileDialog(self); file_dialog.setNameFilter(FILE_DIALOG_FILTER)
        if file_dialog.exec():
            file_paths = file_dialog.selectedFiles()
            if file_paths: self.load_file(file_paths[0])
    
    def load_file(self, file_path: str):
        file_path_obj = Path(file_path); extension = file_path_obj.suffix.lower()
        self.status_bar.showMessage(f"Ê≠£Âú®Âä†ËΩΩÊñá‰ª∂: {file_path_obj.name}...")
        
        # Ê£ÄÊü•Êñá‰ª∂Ë∑ØÂæÑÊòØÂê¶ÂåÖÂê´‰∏≠ÊñáÊàñÁâπÊÆäÂ≠óÁ¨¶
        has_non_ascii = any(ord(c) > 127 for c in file_path)
        if has_non_ascii:
            print(f"Ë≠¶Âëä: Êñá‰ª∂Ë∑ØÂæÑÂåÖÂê´ÈùûASCIIÂ≠óÁ¨¶ÔºåÂèØËÉΩÂØºËá¥ÂÖºÂÆπÊÄßÈóÆÈ¢ò: {file_path}")
        
        self.graphics_scene.clear()
        self.clear_annotations()
        self.clear_ocr_results()
        self.clear_masked_regions()
        self.current_pixmap = None
        
        try:
            pixmap = None
            if extension in SUPPORTED_IMAGE_FORMATS:
                pixmap = FileLoader.load_image(str(file_path))
                if pixmap: self.current_file_path = str(file_path)
            elif extension in SUPPORTED_PDF_FORMATS:
                # Êñ∞Â¢ûPDFËá™Âä®ËΩ¨Êç¢ÂäüËÉΩ
                # 1. ÂÖàÂ∞ùËØïÊôÆÈÄöÂä†ËΩΩPDF
                zoom_factor = PDF_QUALITY_OPTIONS.get(self.pdf_quality_combo.currentText(), 4.0)
                self.status_bar.showMessage(f"Ê≠£Âú®‰ª• {self.pdf_quality_combo.currentText()} Ë¥®ÈáèÂä†ËΩΩPDF...")
                
                # Ëá™Âä®Â∞ÜPDFËΩ¨Êç¢‰∏∫PNGÔºå‰ª•‰æøÊõ¥Â•ΩÂú∞ÊîØÊåÅOCR
                self.status_bar.showMessage("Ê≠£Âú®Â∞ÜPDFËΩ¨Êç¢‰∏∫PNGÊ†ºÂºè...")
                png_path, error = FileLoader.convert_pdf_to_png(str(file_path), zoom_factor=zoom_factor)
                
                if png_path and not error:
                    # Â¶ÇÊûúËΩ¨Êç¢ÊàêÂäüÔºåÂä†ËΩΩPNGÊñá‰ª∂
                    pixmap = FileLoader.load_image(png_path)
                    if pixmap:
                        self.current_file_path = png_path  # ‰ΩøÁî®ËΩ¨Êç¢ÂêéÁöÑPNGË∑ØÂæÑ
                        self.status_bar.showMessage(f"PDFÂ∑≤ËΩ¨Êç¢‰∏∫PNGÂπ∂Âä†ËΩΩ: {Path(png_path).name}")
                        
                        # ÊòæÁ§∫ËΩ¨Êç¢ÊàêÂäü‰ø°ÊÅØ
                        QMessageBox.information(
                            self, 
                            "PDFËΩ¨Êç¢ÊàêÂäü", 
                            f"PDFÂ∑≤Ëá™Âä®ËΩ¨Êç¢‰∏∫PNGÊ†ºÂºè‰ª•ÊèêÂçáOCRËØÜÂà´ÊïàÊûú„ÄÇ\nPNGÊñá‰ª∂Â∑≤‰øùÂ≠òËá≥:\n{png_path}"
                        )
                else:
                    # ËΩ¨Êç¢Â§±Ë¥•ÔºåÂ∞ùËØïÁõ¥Êé•Âä†ËΩΩPDF
                    self.status_bar.showMessage(f"PNGËΩ¨Êç¢Â§±Ë¥•: {error}ÔºåÂ∞ùËØïÁõ¥Êé•Âä†ËΩΩPDF...")
                    pixmap = FileLoader.load_pdf(str(file_path), zoom_factor=zoom_factor)
                    if pixmap: self.current_file_path = str(file_path)
            elif extension in SUPPORTED_DXF_FORMATS:
                FileLoader.load_dxf(str(file_path), self.graphics_scene)
                self.graphics_view.fitInView(self.graphics_scene.itemsBoundingRect(), Qt.KeepAspectRatio)
                self.current_file_path = None
                self.status_bar.showMessage(f"‚úÖ DXFÊñá‰ª∂Âä†ËΩΩÊàêÂäü: {file_path_obj.name} (‰∏çÊîØÊåÅOCR)", 5000)
                QMessageBox.information(self, "ÊèêÁ§∫", "DXFÊñá‰ª∂Â∑≤Âä†ËΩΩÔºå‰ΩÜ‰∏çÊîØÊåÅOCRÊñáÂ≠óËØÜÂà´ÂäüËÉΩ")
            else:
                QMessageBox.warning(self, "ÈîôËØØ", f"‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè: {extension}")
                self.status_bar.showMessage(f"‚ùå ‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè: {extension}", 3000); return
            
            if pixmap:
                self.current_pixmap = pixmap
                self.graphics_scene.addPixmap(pixmap)
                self.graphics_view.fitInView(self.graphics_scene.itemsBoundingRect(), Qt.KeepAspectRatio)
                self.status_bar.showMessage(f"‚úÖ Êñá‰ª∂Âä†ËΩΩÊàêÂäü: {file_path_obj.name} ({pixmap.width()}x{pixmap.height()})", 5000)
            elif self.current_file_path is None and extension not in SUPPORTED_DXF_FORMATS:
                 QMessageBox.warning(self, "ÈîôËØØ", "Êó†Ê≥ïÂä†ËΩΩÊñá‰ª∂")
                 self.status_bar.showMessage("‚ùå Êñá‰ª∂Âä†ËΩΩÂ§±Ë¥•", 3000)
            
            self.ocr_button.setEnabled(self.current_file_path is not None)
        except Exception as e:
            QMessageBox.critical(self, "ÈîôËØØ", f"Âä†ËΩΩÊñá‰ª∂Êó∂ÂèëÁîüÈîôËØØ: {str(e)}")
            self.status_bar.showMessage(f"‚ùå Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•: {str(e)}", 5000)
            self.current_file_path = None

    def simulate_ai_recognition(self):
        self.start_ocr_recognition()

    def start_ocr_recognition(self):
        """ÂêØÂä®OCRËØÜÂà´ËøáÁ®ã"""
        if not HAS_OCR_SUPPORT:
            QMessageBox.warning(self, "ÂäüËÉΩÁº∫Â§±", "OCRÂäüËÉΩÈúÄË¶ÅPaddleOCRÂíå‰æùËµñÂåÖ„ÄÇËØ∑ÂÆâË£ÖÊâÄÈúÄ‰æùËµñ„ÄÇ")
            return
        
        if not self.current_pixmap:
            QMessageBox.information(self, "ÊèêÁ§∫", "ËØ∑ÂÖàÊâìÂºÄÂõæÁâáÊñá‰ª∂„ÄÇ")
            return
            
        # ‰øùÂ≠òÂ∑≤ÊúâÁöÑOCRÁªìÊûúÔºåËÄå‰∏çÊòØÊ∏ÖÈô§
        existing_results = self.ocr_results.copy()
        # Âè™Ê∏ÖÈô§ÊòæÁ§∫Ôºå‰∏çÊ∏ÖÈô§ÁªìÊûúÊï∞ÊçÆ
        self.clear_ocr_display()
        
        # Ëé∑ÂèñËØ≠Ë®ÄÈÖçÁΩÆ
        lang_text = self.language_combo.currentText()
        lang_code = DEFAULT_OCR_LANGUAGES.get(lang_text, ["ch_sim"])
        
        # Ëé∑ÂèñÁéØÂ¢ÉÈÖçÁΩÆ
        force_cpu = self.cpu_checkbox.isChecked()
        use_gpu = self.gpu_checkbox.isChecked() and not force_cpu
        
        # Ëé∑ÂèñCPUÁ∫øÁ®ãÊï∞
        cpu_threads = self.threads_spinbox.value()
        
        # ÊòæÁ§∫ËÆæÂ§áÊ®°Âºè
        device_mode = "CPU" if force_cpu else ("GPU" if use_gpu else "Ëá™Âä®")
        self.status_bar.showMessage(f"Ê≠£Âú®ËøõË°åOCRÊñáÊú¨ËØÜÂà´... (‰ΩøÁî®{device_mode}Ê®°Âºè)")
        
        # Ëé∑ÂèñÂ±èËîΩÂå∫ÂüüÊï∞ÊçÆ
        masked_regions_data = [{'x': r.x(), 'y': r.y(), 'width': r.width(), 'height': r.height()} for r in self.masked_regions]
        
        # ÂàõÂª∫OCRÂ∑•‰ΩúÂô®
        self.ocr_worker = PaddleOCRWorker(
            self.current_file_path, 
            lang_code, 
            masked_regions_data,
            force_cpu=force_cpu,
            cpu_threads=cpu_threads  # ‰º†ÈÄíÁ∫øÁ®ãÊï∞
        )
        
        # ËøûÊé•‰ø°Âè∑
        self.ocr_worker.signals.progress.connect(self.on_ocr_progress)
        self.ocr_worker.signals.error.connect(self.on_ocr_error)
        
        # ‰øÆÊîπon_ocr_finishedËøûÊé•ÔºåÂêàÂπ∂Áé∞ÊúâÁªìÊûú
        self.ocr_worker.signals.finished.connect(
            lambda results: self.on_ocr_finished(results, existing_results)
        )
        
        # ÊòæÁ§∫ËøõÂ∫¶Êù°
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        # ÂêØÂä®Á∫øÁ®ã
        self.thread_pool.start(self.ocr_worker)

    def on_ocr_progress(self, progress: int):
        self.progress_bar.setValue(progress)

    def on_ocr_error(self, error_msg: str):
        self.ocr_button.setEnabled(True); self.ocr_button.setText("üîç ÂºÄÂßãOCRËØÜÂà´")
        self.progress_bar.setVisible(False)
        QMessageBox.critical(self, "OCRËØÜÂà´ÈîôËØØ", error_msg)

    def on_ocr_finished(self, results: List[dict], existing_results: List[dict] = None):
        self.ocr_button.setEnabled(True); self.ocr_button.setText("üîç ÂºÄÂßãOCRËØÜÂà´")
        self.progress_bar.setVisible(False)
        if self.is_selecting_mask: self.toggle_mask_selection(False)
        
        # ÂêàÂπ∂Áé∞ÊúâÁöÑOCRÁªìÊûúÂíåÊñ∞ÁöÑÁªìÊûú
        if existing_results:
            # ÂàõÂª∫‰∏Ä‰∏™ÈõÜÂêàÊù•Ê£ÄÊü•ÈáçÂ§çÈ°π
            existing_boxes = set()
            for r in existing_results:
                if 'bbox' in r:
                    # Â∞ÜbboxËΩ¨Êç¢‰∏∫ÂèØÂìàÂ∏åÊ†ºÂºè‰ª•Ê£ÄÊü•ÈáçÂ§ç
                    bbox_tuple = tuple(tuple(point) for point in r['bbox'])
                    existing_boxes.add(bbox_tuple)
            
            # ËøáÊª§ÊéâÈáçÂè†ÁöÑÊñ∞ÁªìÊûú
            new_results = []
            for r in results:
                if 'bbox' in r:
                    bbox_tuple = tuple(tuple(point) for point in r['bbox'])
                    if bbox_tuple not in existing_boxes:
                        new_results.append(r)
                else:
                    new_results.append(r)
            
            # ÂêàÂπ∂ÁªìÊûú
            self.ocr_results = existing_results + new_results
        else:
            self.ocr_results = results
            
        self.update_ocr_stats()
        self.display_ocr_results()
        
        # ÊòæÁ§∫Â∏¶ÊúâÊó∂Èó¥‰ø°ÊÅØÁöÑÂÆåÊàêÊ∂àÊÅØ
        message = f"ÊàêÂäüËØÜÂà´Âá∫ {len(results)} ‰∏™ÊñáÊú¨Âå∫Âüü„ÄÇ\nÊÇ®ÂèØ‰ª•ÈÄâÊã©ÂàõÂª∫Ê†áÊ≥®ÊàñËøõ‰∏ÄÊ≠•Á≠õÈÄâÁªìÊûú„ÄÇ"
        
        # Ê∑ªÂä†Êñá‰ª∂Âêç
        if self.current_file_path:
            message += f"\n\nÊñá‰ª∂: {Path(self.current_file_path).name}"
        
        # Ê∑ªÂä†Êó•ÊúüÊó∂Èó¥
        now = datetime.now()
        message += f"\nÂÆåÊàêÊó∂Èó¥: {now.strftime('%Y-%m-%d %H:%M:%S')}"
        
        QMessageBox.information(self, "OCRËØÜÂà´ÂÆåÊàê", message)

    def update_ocr_stats(self):
        total_count = len(self.ocr_results)
        type_counts = {}
        for result in self.ocr_results: 
            result_type = result.get('type', 'unknown')
            type_counts[result_type] = type_counts.get(result_type, 0) + 1
        stats_text = f"ËØÜÂà´ÁªìÊûú: {total_count}‰∏™ÊñáÊú¨"
        if type_counts: 
            stats_text += f" ({', '.join([f'{k}({v})' for k, v in type_counts.items()])})"
        self.ocr_stats_label.setText(stats_text)

    def display_ocr_results(self):
        self.clear_ocr_display()
        for i, result in enumerate(self.ocr_results): 
            self.create_ocr_bbox_item(result, i)

    def create_ocr_bbox_item(self, ocr_result, index):
        if not HAS_OCR_SUPPORT: return
        bbox = ocr_result['bbox']
        # Ê∑ªÂä†Ë∞ÉËØïËæìÂá∫Êü•ÁúãËæπÁïåÊ°Ü‰ø°ÊÅØ
        # print(f"OCR Box {index}: {ocr_result.get('text', '')}, bbox: {bbox}")
        
        bbox_array = np.array(bbox)
        path = QPainterPath()
        path.moveTo(bbox_array[0][0], bbox_array[0][1])
        for point in bbox_array[1:]: 
            path.lineTo(point[0], point[1])
        path.closeSubpath()
        from PySide6.QtWidgets import QGraphicsPathItem
        bbox_item = QGraphicsPathItem(path)
        text_type = ocr_result.get('type', 'annotation')
        color = QColor(*OCR_TEXT_TYPE_COLORS.get(text_type, OCR_TEXT_TYPE_COLORS['annotation']))
        bbox_item.setPen(QPen(color, 2))
        bbox_item.setBrush(QBrush(color))
        self.graphics_scene.addItem(bbox_item)
        bbox_item.ocr_result = ocr_result
        bbox_item.ocr_index = index



    def clear_ocr_display(self):
        items_to_remove = [item for item in self.graphics_scene.items() if hasattr(item, 'ocr_result')]
        for item in items_to_remove: 
            self.graphics_scene.removeItem(item)

    def clear_ocr_results(self):
        self.ocr_results = []; self.clear_ocr_display(); self.update_ocr_stats()

    def filter_ocr_results(self):
        filter_type = self.filter_combo.currentText()
        if filter_type == "ÂÖ®ÈÉ®": 
            filtered_results = self.ocr_results
        else:
            target_type = OCR_FILTER_TYPE_MAP.get(filter_type, "annotation")
            filtered_results = [r for r in self.ocr_results if r.get('type', 'annotation') == target_type]
        self.clear_ocr_display()
        for i, result in enumerate(filtered_results):
            if result in self.ocr_results:
                original_index = self.ocr_results.index(result)
                self.create_ocr_bbox_item(result, original_index)

    def create_annotations_from_ocr(self):
        if not self.ocr_results:
            QMessageBox.warning(self, "Ë≠¶Âëä", "Ê≤°ÊúâOCRËØÜÂà´ÁªìÊûú!")
            return
            
        # Á°Æ‰øùannotation_counterÊòØÂΩìÂâçÊúÄÂ§ßIDÂÄº
        if self.annotations:
            max_id = max(ann.annotation_id for ann in self.annotations)
            self.annotation_counter = max(self.annotation_counter, max_id)
            
        created_count = 0
        confidence_threshold = self.confidence_slider.value() / 100.0
        
        for result in self.ocr_results:
            if result.get('confidence', 0) >= confidence_threshold:
                self.create_annotation_from_ocr_result(result)
                created_count += 1
                
        QMessageBox.information(self, "ÂàõÂª∫ÂÆåÊàê", f"ÊàêÂäüÂàõÂª∫‰∫Ü {created_count} ‰∏™Ê†áÊ≥®„ÄÇ")
        self.refresh_annotation_list()

    def _parse_annotation_text(self, text: str) -> dict:
        text_main = re.sub(r'\s*\(.*\)', '', text).strip()
        match = re.match(r'([Œ¶‚àÖ√∏MR])\s*(\d+\.?\d*)', text_main, re.IGNORECASE)
        if match: return {'type': 'Áõ¥ÂæÑ(Œ¶)', 'dimension': match.group(2)}
        return {'type': 'Á∫øÊÄß', 'dimension': text_main}
        
    def create_annotation_from_ocr_result(self, ocr_result: dict):
        parsed_data = self._parse_annotation_text(ocr_result['text'])
        annotation_text = f"ÂéüÂßãÊñáÊú¨: {ocr_result['text']}"
        
        # Êõ¥ÊîπÈîöÁÇπ‰ΩçÁΩÆËÆ°ÁÆó
        if 'bbox' in ocr_result:
            bbox = ocr_result['bbox']
            bbox_array = np.array(bbox)
            
            # ËÆ°ÁÆóËæπÁïåÊ°ÜÁöÑ‰∏≠ÂøÉÁÇπ
            center_x = np.mean(bbox_array[:, 0])
            center_y = np.mean(bbox_array[:, 1])
            
            # ËÆ°ÁÆóËæπÁïåÊ°ÜÂÆΩÂ∫¶
            x_min, x_max = np.min(bbox_array[:, 0]), np.max(bbox_array[:, 0])
            width = x_max - x_min
            
            # ËÆæÁΩÆÈîöÁÇπÂú®ÊñáÊú¨Ê°ÜÂè≥‰æß‰∏≠Èó¥‰ΩçÁΩÆ
            anchor_x = x_max + width * 0.2  # ÂêëÂè≥ÂÅèÁßªÂÆΩÂ∫¶ÁöÑ20%
            anchor_y = center_y
            anchor_point = QPointF(anchor_x, anchor_y)
        else:
            # Â¶ÇÊûúÊ≤°ÊúâËæπÁïåÊ°ÜÔºå‰ΩøÁî®centerÂ≠óÊÆµ
            center = ocr_result.get('center', (0, 0))
            anchor_point = QPointF(center[0], center[1])
        
        # ÂàõÂª∫Ê†áÊ≥®
        annotation = self._create_new_annotation(
            anchor_point=anchor_point,
            text=annotation_text,
            dimension=parsed_data.get('dimension', ''),
            dimension_type=parsed_data.get('type', ''),
            style=OCR_TYPE_TO_STYLE.get(ocr_result.get('type', 'annotation'), 'default')
        )
        
        # Â¶ÇÊûúÂ≠òÂú®ËæπÁïåÊ°Ü‰ø°ÊÅØÔºå‰øùÂ≠òÂà∞Ê†áÊ≥®È°π‰∏≠
        if 'bbox' in ocr_result:
            bbox = ocr_result['bbox']
            # Â∞ÜnumpyÊï∞ÁªÑËΩ¨Êç¢‰∏∫QPointFÂàóË°®
            points = [QPointF(point[0], point[1]) for point in bbox]
            # Ë∞ÉËØïËæìÂá∫
            # print(f"OCR Text: {ocr_result['text']}, Points: {[(p.x(), p.y()) for p in points]}")
            # Â≠òÂÇ®ËæπÁïåÊ°Ü‰ø°ÊÅØ
            annotation.set_bbox_points(points)
        
        return annotation

    def _create_new_annotation(self, anchor_point: QPointF, text: str = "", dimension: str = "", dimension_type: str = "", style: str = "default"):
        self.annotation_counter += 1
        shape_map = {"Á©∫ÂøÉÂúÜ": "circle", "ÂÆûÂøÉÂúÜ": "solid_circle", "‰∫îËßíÊòü": "pentagram", "‰∏âËßíÂΩ¢": "triangle"}
        selected_shape = shape_map.get(self.shape_combo.currentText(), "circle")
        
        # ÂàõÂª∫Ê†áÊ≥®È°πÔºàÂàùÂßãÂ§ßÂ∞è‰∏∫15ÔºåÂêéÁª≠‰ºöË∞ÉÊï¥Ôºâ
        annotation = BubbleAnnotationItem(
            annotation_id=self.annotation_counter,
            anchor_point=anchor_point,
            text=text,
            style=style,
            shape=selected_shape,
            color=self.next_annotation_color,
            size=15,  # ‰∏¥Êó∂Â§ßÂ∞èÔºå‰ºöÂü∫‰∫éscale_factorË∞ÉÊï¥
            dimension=dimension,
            dimension_type=dimension_type
        )
        
        # ËÆæÁΩÆÊØî‰æãÂõ†Â≠êÂπ∂Ëß¶ÂèëÂ§ßÂ∞èËá™Âä®ËÆ°ÁÆó
        annotation.auto_radius = True
        annotation.scale_factor = self.next_annotation_scale
        
        # ‰ΩøÁî®-1Ëß¶ÂèëËá™Âä®ËÆ°ÁÆóÂ§ßÂ∞è
        annotation.change_size(-1)
        
        # Ê∏ÖÈô§È¢úËâ≤ËÆæÁΩÆÔºà‰∏ÄÊ¨°ÊÄßÁöÑÔºâ
        if self.next_annotation_color: self.next_annotation_color = None
        
        annotation.data_updated.connect(self.annotation_table.update_annotation_data)
        annotation.selected.connect(self.on_annotation_selected)
        annotation.moved.connect(self.on_annotation_moved)
        annotation.delete_requested.connect(self.delete_annotation)
        annotation.style_change_requested.connect(self.on_annotation_style_changed)
        annotation.shape_change_requested.connect(self.on_annotation_shape_changed)
        annotation.color_change_requested.connect(self.on_annotation_color_changed)
        annotation.size_change_requested.connect(self.on_annotation_size_changed)
        
        self.graphics_scene.addItem(annotation)
        self.annotations.append(annotation)
        self.annotation_table.add_annotation(annotation, {})
        
        return annotation

    def on_annotation_selected(self, annotation: BubbleAnnotationItem):
        for ann in self.annotations: ann.set_highlighted(False)
        self.current_annotation = annotation; annotation.set_highlighted(True)
        
        self.property_editor.set_annotation(annotation, self.current_pixmap)
        
        self.annotation_table.highlight_annotation(annotation.annotation_id)
        style_text = "Ëá™ÂÆö‰πâ" if annotation.custom_color else STYLE_NAME_MAP.get(annotation.style, "ÈªòËÆ§")
        self.style_combo.blockSignals(True); self.style_combo.setCurrentText(style_text); self.style_combo.blockSignals(False)
        shape_map_rev = {"circle": "Á©∫ÂøÉÂúÜ", "solid_circle": "ÂÆûÂøÉÂúÜ", "pentagram": "‰∫îËßíÊòü", "triangle": "‰∏âËßíÂΩ¢"}
        shape_text = shape_map_rev.get(annotation.shape_type, "Á©∫ÂøÉÂúÜ")
        self.shape_combo.blockSignals(True); self.shape_combo.setCurrentText(shape_text); self.shape_combo.blockSignals(False)
        
        # Êõ¥Êñ∞ÊªëÂùó‰∏∫ÂΩìÂâçÊØî‰æã
        self.size_slider.blockSignals(True)
        scale_percent = int(annotation.scale_factor * 100)
        self.size_slider.setValue(scale_percent)
        self.size_label.setText(f"{scale_percent}%")
        self.size_slider.blockSignals(False)
        
        self.update_color_button_display()
    
    def on_annotation_moved(self, annotation: BubbleAnnotationItem, position: QPointF):
        if annotation == self.current_annotation:
            self.property_editor.update_preview()
    
    def select_annotation_by_id(self, annotation_id: int):
        for annotation in self.annotations:
            if annotation.annotation_id == annotation_id:
                self.graphics_view.centerOn(annotation)
                self.graphics_scene.clearSelection()
                annotation.setSelected(True)
                self.on_annotation_selected(annotation)
                break
    
    def toggle_area_selection(self, checked: bool):
        self.graphics_view.set_selection_mode(checked)
        self.area_select_action.setText("ÈÄÄÂá∫Âå∫ÂüüOCR" if checked else "Âå∫ÂüüOCRÊ†áÊ≥®")
        
        # Á¶ÅÁî®ÊàñÂêØÁî®ÂÖ∂‰ªñÂèØËÉΩÂÜ≤Á™ÅÁöÑÂäüËÉΩ
        if checked:
            # Â¶ÇÊûúÂêØÁî®Âå∫ÂüüÈÄâÊã©ÔºåÁ¶ÅÁî®Â±èËîΩÂå∫ÂüüÈÄâÊã©
            if self.mask_select_action.isChecked():
                self.mask_select_action.blockSignals(True)
                self.mask_select_action.setChecked(False)
                self.mask_select_action.blockSignals(False)
                self.is_selecting_mask = False
            
            # ÊòæÁ§∫ÊèêÁ§∫‰ø°ÊÅØ
            self.status_bar.showMessage("Âå∫ÂüüOCRËØÜÂà´Ê®°ÂºèÔºöËØ∑Âú®ÂõæÁ∫∏‰∏äÊãñÊãΩÈÄâÊã©Ë¶ÅËØÜÂà´ÁöÑÂå∫Âüü...", 5000)
        else:
            self.status_bar.showMessage("Â∑≤ÈÄÄÂá∫Âå∫ÂüüOCRËØÜÂà´Ê®°Âºè", 3000)
    
    def create_annotation_in_area(self, rect: QRectF):
        if self.is_selecting_mask: return
        self._create_new_annotation(
            anchor_point=rect.center(),
            text=f"Âå∫ÂüüÊ†áÊ≥® {self.annotation_counter + 1}"
        )
        self.area_select_action.setChecked(False)
    
    def delete_annotation(self, annotation: BubbleAnnotationItem):
        if annotation in self.annotations:
            self.graphics_scene.removeItem(annotation)
            self.annotations.remove(annotation)
            
            # Â¶ÇÊûúÂΩìÂâçÈÄâ‰∏≠Ê†áÊ≥®ÊòØË¢´Âà†Èô§ÁöÑÊ†áÊ≥®ÔºåÊ∏ÖÈô§ÈÄâÊã©
            if self.current_annotation == annotation:
                self.current_annotation = None
                self.property_editor.set_annotation(None, None)
                
            self.refresh_annotation_list()
    
    def refresh_annotation_list(self):
        self.annotation_table.clear_annotations()
        
        for annotation in self.annotations:
            self.annotation_table.add_annotation(annotation, {})
    
    def on_annotation_style_changed(self, annotation: BubbleAnnotationItem):
        if annotation == self.current_annotation: self.on_annotation_selected(annotation)

    def change_current_annotation_style(self, style_text: str):
        if self.current_annotation and style_text != "Ëá™ÂÆö‰πâ":
            new_style = STYLE_NAME_REVERSE_MAP.get(style_text, "default")
            self.current_annotation.change_style(new_style)

    def on_annotation_shape_changed(self, annotation: BubbleAnnotationItem):
        if annotation == self.current_annotation: self.on_annotation_selected(annotation)

    def change_current_annotation_shape(self, shape_text: str):
        if self.current_annotation:
            shape_map = {"Á©∫ÂøÉÂúÜ": "circle", "ÂÆûÂøÉÂúÜ": "solid_circle", "‰∫îËßíÊòü": "pentagram", "‰∏âËßíÂΩ¢": "triangle"}
            new_shape = shape_map.get(shape_text, "circle")
            self.current_annotation.change_shape(new_shape)

    def on_annotation_color_changed(self, annotation: BubbleAnnotationItem):
        if annotation == self.current_annotation: self.on_annotation_selected(annotation)
        
    def reorder_annotations(self):
        """ÈáçÊñ∞ÊéíÂ∫èÊâÄÊúâÊ∞îÊ≥°Ê†áÊ≥®
        
        ÊåâÁÖß‰ªéÂ∑¶Âà∞Âè≥Ôºå‰ªé‰∏äÂà∞‰∏ãÁöÑÈ°∫Â∫èÈáçÊñ∞ÂØπÊâÄÊúâÊ∞îÊ≥°Ê†áÊ≥®ËøõË°åÁºñÂè∑
        """
        if not self.annotations:
            QMessageBox.information(self, "ÊèêÁ§∫", "Ê≤°ÊúâÊ†áÊ≥®ÂèØ‰ª•ÈáçÊñ∞ÊéíÂ∫è")
            return
            
        # Á°ÆËÆ§ÂØπËØùÊ°Ü
        confirm = QMessageBox.question(
            self, 
            "Á°ÆËÆ§ÈáçÊñ∞ÊéíÂ∫è", 
            "Á°ÆÂÆöË¶ÅÈáçÊñ∞ÊéíÂ∫èÊâÄÊúâÊ∞îÊ≥°Ê†áÊ≥®ÂêóÔºüËøôÂ∞ÜÊîπÂèòÊâÄÊúâÊ†áÊ≥®ÁöÑÁºñÂè∑„ÄÇ",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if confirm != QMessageBox.Yes:
            return
            
        # ÊåâÁÖß‰ΩçÁΩÆÊéíÂ∫è
        # È¶ñÂÖàÂ∞ÜÂú∫ÊôØÂàíÂàÜ‰∏∫ÁΩëÊ†ºÔºåÁÑ∂ÂêéÂú®ÁΩëÊ†ºÂÜÖÊåâÂ∑¶Âà∞Âè≥ÊéíÂ∫è
        # ËøôÂÆûÁé∞‰∫Ü‰ªé‰∏äÂà∞‰∏ãÔºå‰ªéÂ∑¶Âà∞Âè≥ÁöÑËá™ÁÑ∂ÈòÖËØªÈ°∫Â∫èÊéíÂ∫è
        sorted_annotations = sorted(
            self.annotations,
            key=lambda ann: (int(ann.scenePos().y() / BUBBLE_REORDER_GRID_SIZE), ann.scenePos().x())
        )
        
        # ‰øùÂ≠òÂΩìÂâçÈÄâ‰∏≠ÁöÑÊ†áÊ≥®
        current_annotation_id = self.current_annotation.annotation_id if self.current_annotation else None
        
        # ÈáçÊñ∞ÂàÜÈÖçID
        for i, annotation in enumerate(sorted_annotations, 1):
            old_id = annotation.annotation_id
            annotation.annotation_id = i
            
            # Êõ¥Êñ∞ÊñáÊú¨ÔºàÂ¶ÇÊûúÊñáÊú¨‰∏≠ÂåÖÂê´IDÔºâ
            if str(old_id) in annotation.text:
                annotation.text = annotation.text.replace(str(old_id), str(i))
                
            # Êõ¥Êñ∞Ê∞îÊ≥°ÊòæÁ§∫
            annotation.update_annotation_id_display()
            
            # ÂèëÈÄÅÊï∞ÊçÆÊõ¥Êñ∞‰ø°Âè∑
            annotation.data_updated.emit(annotation)
        
        # ÈáçÁΩÆ‰∏ã‰∏Ä‰∏™Ê†áÊ≥®ÁöÑID
        self.annotation_counter = len(sorted_annotations)
        
        # Âà∑Êñ∞Ê†áÊ≥®ÂàóË°®
        self.refresh_annotation_list()
        
        # ÊÅ¢Â§çÈÄâ‰∏≠ÁöÑÊ†áÊ≥®ÔºàÂ¶ÇÊûúÂèØËÉΩÔºâ
        if current_annotation_id is not None:
            # Â∞ùËØïÊâæÂà∞ÂéüÊù•ÁöÑÊ†áÊ≥®
            for annotation in self.annotations:
                if annotation.annotation_id == current_annotation_id:
                    self.select_annotation_by_id(annotation.annotation_id)
                    break
        
        self.status_bar.showMessage(f"Â∑≤ÊàêÂäüÈáçÊñ∞ÊéíÂ∫è {len(sorted_annotations)} ‰∏™Ê∞îÊ≥°Ê†áÊ≥®Ôºà‰ªé‰∏äÂà∞‰∏ãÔºå‰ªéÂ∑¶Âà∞Âè≥Ôºâ", 3000)

    def select_annotation_color(self):
        initial_color = QColor("blue")
        if self.current_annotation and self.current_annotation.custom_color:
            initial_color = self.current_annotation.custom_color
        elif self.next_annotation_color:
            initial_color = self.next_annotation_color
        color = QColorDialog.getColor(initial_color, self, "ÈÄâÊã©Ê†áÊ≥®È¢úËâ≤")
        if color.isValid():
            if self.current_annotation:
                self.current_annotation.change_color(color)
            else:
                self.next_annotation_color = color
                self.update_color_button_display()
                self.status_bar.showMessage(f"‰∏ã‰∏Ä‰∏™Ê†áÊ≥®ÁöÑÈ¢úËâ≤Â∑≤ËÆæÁΩÆ‰∏∫ {color.name()}", 3000)

    def update_color_button_display(self):
        color_to_show = None
        if self.current_annotation and self.current_annotation.custom_color:
            color_to_show = self.current_annotation.custom_color
        elif self.next_annotation_color:
            color_to_show = self.next_annotation_color
        if color_to_show and color_to_show.isValid():
            self.color_button.setStyleSheet(f"QPushButton {{ background-color: {color_to_show.name()}; color: {'white' if color_to_show.lightnessF() < 0.5 else 'black'}; border: 1px solid grey; font-weight: bold; }}")
        else:
            self.color_button.setStyleSheet("")
            self.next_annotation_color = None

    def on_annotation_size_changed(self, annotation: BubbleAnnotationItem):
        if annotation == self.current_annotation: self.on_annotation_selected(annotation)

    def change_annotation_size(self, percent: int):
        """Êõ¥ÊîπÊ≥®ÈáäÂ§ßÂ∞èÔºàÂü∫‰∫éÊØî‰æãÔºâ
        
        Args:
            percent: Â§ßÂ∞èÊØî‰æãÔºåËåÉÂõ¥50-160ÔºàÂØπÂ∫î50%-160%Ôºâ
        """
        # Ë∞ÉËØï‰ø°ÊÅØÔºåÂ∏ÆÂä©ËøΩË∏™ÊªëÂùóÈóÆÈ¢ò
        print(f"ÊªëÂùóÂÄºÂèòÂåñ: {percent}%")
        
        # ÊòæÁ§∫ÁôæÂàÜÊØîÊñáÊú¨
        self.size_label.setText(f"{percent}%")
        
        # Â∞ÜÁôæÂàÜÊØîËΩ¨Êç¢‰∏∫ÊØî‰æãÂõ†Â≠êÔºåÊØîÂ¶Ç100%=1.0Ôºå50%=0.5
        scale_factor = percent / 100.0
        
        if self.current_annotation:
            print(f"Â∫îÁî®ÊØî‰æã {scale_factor} Âà∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑÊ∞îÊ≥° ID: {self.current_annotation.annotation_id}")
            # È¶ñÂÖàËÆæÁΩÆÊØî‰æãÂõ†Â≠ê
            self.current_annotation.scale_factor = scale_factor
            # Á°Æ‰øùauto_radiusËÆæÁΩÆ‰∏∫TrueÔºåËøôÊ†∑Êâç‰ºö‰ΩøÁî®ÊØî‰æãÂõ†Â≠ê
            self.current_annotation.auto_radius = True
            # Âº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆóÊ∞îÊ≥°Â∞∫ÂØ∏Âπ∂Êõ¥Êñ∞ÊòæÁ§∫
            self.current_annotation.change_size(-1)
            # Âà∑Êñ∞Â±ûÊÄßÁºñËæëÂô®
            self.property_editor.update_preview()
        else:
            # ‰øùÂ≠ò‰∏∫‰∏ã‰∏Ä‰∏™Ê†áÊ≥®ÁöÑÈªòËÆ§ÊØî‰æã
            self.next_annotation_size = -1  # Ê†áËÆ∞‰∏∫Ëá™Âä®
            self.next_annotation_scale = scale_factor
            self.status_bar.showMessage(f"‰∏ã‰∏Ä‰∏™Ê†áÊ≥®ÁöÑÂ§ßÂ∞èÂ∑≤ËÆæÁΩÆ‰∏∫ {percent}%", 3000)
    
    def clear_annotations(self):
        if self.annotations:
            # ÁßªÈô§ÊâÄÊúâÊ†áÊ≥®
            for annotation in self.annotations.copy():
                self.graphics_scene.removeItem(annotation)
                
            self.annotations.clear()
            self.annotation_table.clear_annotations()
            self.property_editor.set_annotation(None, None)
            self.current_annotation = None
            
            # ÈáçÁΩÆÊ†áÊ≥®ËÆ°Êï∞Âô®
            self.annotation_counter = 0
    
    def toggle_mask_selection(self, checked: bool):
        self.is_selecting_mask = checked; self.graphics_view.set_selection_mode(checked)
        if hasattr(self, 'mask_select_action'):
            self.mask_select_action.blockSignals(True); self.mask_select_action.setChecked(checked); self.mask_select_action.blockSignals(False)
        if checked and hasattr(self, 'area_select_action'):
            self.area_select_action.blockSignals(True); self.area_select_action.setChecked(False); self.area_select_action.blockSignals(False)
        self.status_bar.showMessage("Â±èËîΩÂå∫ÂüüÈÄâÊã©Ê®°ÂºèÔºöÊãñÊãΩÈº†Ê†áÈÄâÊã©Ë¶ÅÂ±èËîΩÁöÑÂå∫Âüü" if checked else "Â∑≤ÈÄÄÂá∫Â±èËîΩÂå∫ÂüüÈÄâÊã©Ê®°Âºè", 3000 if not checked else 0)
    
    def handle_area_selection(self, rect: QRectF):
        if self.is_selecting_mask:
            self.add_masked_region(rect)
        else:
            # ‰øÆÊîπ‰∏∫ÂØπÈÄâ‰∏≠Âå∫ÂüüËøõË°åOCRËØÜÂà´
            self.run_ocr_on_selected_area(rect)
    
    def add_masked_region(self, rect: QRectF):
        self.masked_regions.append(rect)
        self.display_masked_region(rect, len(self.masked_regions) - 1)
        self.update_mask_count()
        self.status_bar.showMessage(f"Â∑≤Ê∑ªÂä†Â±èËîΩÂå∫Âüü {len(self.masked_regions)}", 2000)
    
    def display_masked_region(self, rect: QRectF, index: int):
        from PySide6.QtWidgets import QGraphicsRectItem
        mask_item = QGraphicsRectItem(rect)
        mask_color = QColor(255, 0, 0, 80); border_color = QColor(255, 0, 0, 200)
        mask_item.setPen(QPen(border_color, 2, Qt.DashLine)); mask_item.setBrush(QBrush(mask_color))
        mask_item.mask_region_index = index; mask_item.setZValue(100)
        self.graphics_scene.addItem(mask_item)
    
    def clear_masked_regions(self):
        self.masked_regions.clear()
        items_to_remove = [item for item in self.graphics_scene.items() if hasattr(item, 'mask_region_index')]
        for item in items_to_remove:
            self.graphics_scene.removeItem(item)
        self.update_mask_count()
        self.status_bar.showMessage("Â∑≤Ê∏ÖÈô§ÊâÄÊúâÂ±èËîΩÂå∫Âüü", 2000)
    
    def update_mask_count(self): pass
    
    def is_point_in_masked_region(self, x: float, y: float) -> bool:
        return any(region.contains(QPointF(x, y)) for region in self.masked_regions)
    
    def is_bbox_in_masked_region(self, bbox) -> bool:
        if not self.masked_regions: return False
        if hasattr(bbox, '__len__') and len(bbox) >= 4:
            if HAS_OCR_SUPPORT:
                x_min, y_min = np.min(bbox, axis=0)
                x_max, y_max = np.max(bbox, axis=0)
            else:
                x_coords, y_coords = [p[0] for p in bbox], [p[1] for p in bbox]
                x_min, x_max, y_min, y_max = min(x_coords), max(x_coords), min(y_coords), max(y_coords)
            bbox_rect = QRectF(x_min, y_min, x_max - x_min, y_max - y_min)
        else:
            bbox_rect = bbox
        return any(region.intersects(bbox_rect) for region in self.masked_regions)

    def on_gpu_checkbox_toggled(self, checked):
        """ÂΩìGPUÂ§çÈÄâÊ°ÜÁä∂ÊÄÅÂèòÂåñÊó∂ÔºåÊõ¥Êñ∞CPUÂ§çÈÄâÊ°ÜÁä∂ÊÄÅ"""
        if checked and self.cpu_checkbox.isChecked():
            self.cpu_checkbox.blockSignals(True)
            self.cpu_checkbox.setChecked(False)
            self.cpu_checkbox.blockSignals(False)
            # Á¶ÅÁî®Á∫øÁ®ãÊï∞ËæìÂÖ•Ê°Ü
            self.threads_spinbox.setEnabled(False)

    def on_cpu_checkbox_toggled(self, checked):
        """ÂΩìCPUÂ§çÈÄâÊ°ÜÁä∂ÊÄÅÂèòÂåñÊó∂ÔºåÊõ¥Êñ∞GPUÂ§çÈÄâÊ°ÜÁä∂ÊÄÅ"""
        if checked and self.gpu_checkbox.isChecked():
            self.gpu_checkbox.blockSignals(True)
            self.gpu_checkbox.setChecked(False)
            self.gpu_checkbox.blockSignals(False)
        # Ê†πÊçÆCPUÈÄâÊã©Áä∂ÊÄÅÂêØÁî®/Á¶ÅÁî®Á∫øÁ®ãÊï∞ËæìÂÖ•Ê°Ü    
        self.threads_spinbox.setEnabled(checked)

    def change_current_annotation_text(self, new_text: str):
        """‰øÆÊîπÂΩìÂâçÈÄâ‰∏≠Ê†áÊ≥®ÁöÑÊñáÊú¨ÂÜÖÂÆπ"""
        if self.current_annotation and self.current_annotation.text != new_text:
            self.current_annotation.set_text(new_text)
            return True
        return False

    def run_ocr_on_selected_area(self, rect: QRectF):
        """ÂØπÈÄâ‰∏≠Âå∫ÂüüËøõË°åOCRËØÜÂà´"""
        if not HAS_OCR_SUPPORT:
            QMessageBox.warning(self, "ÂäüËÉΩÁº∫Â§±", "OCRÂäüËÉΩÈúÄË¶ÅPaddleOCRÂíå‰æùËµñÂåÖ„ÄÇËØ∑ÂÆâË£ÖÊâÄÈúÄ‰æùËµñ„ÄÇ")
            self.create_annotation_in_area(rect)  # ‰ªçÁÑ∂ÂàõÂª∫Âå∫ÂüüÊ†áÊ≥®
            return
        
        if not self.current_pixmap:
            QMessageBox.information(self, "ÊèêÁ§∫", "ËØ∑ÂÖàÊâìÂºÄÂõæÁâáÊñá‰ª∂„ÄÇ")
            return
            
        # ‰ªéÂΩìÂâçÂõæÂÉè‰∏≠Êà™ÂèñÈÄâÂÆöÂå∫Âüü
        x, y, width, height = rect.x(), rect.y(), rect.width(), rect.height()
        
        # Á°Æ‰øùÂùêÊ†áÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
        x = max(0, int(x))
        y = max(0, int(y))
        width = min(int(width), self.current_pixmap.width() - x)
        height = min(int(height), self.current_pixmap.height() - y)
        
        # ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂‰øùÂ≠òÈÄâÂÆöÂå∫Âüü
        import tempfile
        import os
        
        with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:
            temp_path = temp_file.name
        
        # Êà™ÂèñÂπ∂‰øùÂ≠òÂå∫ÂüüÂõæÂÉè
        cropped_pixmap = self.current_pixmap.copy(x, y, width, height)
        cropped_pixmap.save(temp_path)
        
        self.status_bar.showMessage("Ê≠£Âú®ÂØπÈÄâ‰∏≠Âå∫ÂüüËøõË°åOCRËØÜÂà´...")
        
        # Ëé∑ÂèñËØ≠Ë®ÄÈÖçÁΩÆ
        lang_text = self.language_combo.currentText()
        lang_code = DEFAULT_OCR_LANGUAGES.get(lang_text, ["ch_sim"])
        
        # Ëé∑ÂèñÁéØÂ¢ÉÈÖçÁΩÆ
        force_cpu = self.cpu_checkbox.isChecked()
        use_gpu = self.gpu_checkbox.isChecked() and not force_cpu
        
        # Ëé∑ÂèñCPUÁ∫øÁ®ãÊï∞
        cpu_threads = self.threads_spinbox.value()
        
        # ÂàõÂª∫Âå∫ÂüüOCRÂ∑•‰ΩúÂô®
        self.area_ocr_worker = PaddleOCRWorker(
            temp_path, 
            lang_code, 
            [],  # Âå∫ÂüüËØÜÂà´‰∏çÈúÄË¶ÅÂ±èËîΩÂå∫Âüü
            force_cpu=force_cpu,
            cpu_threads=cpu_threads
        )
        
        # ËøûÊé•‰ø°Âè∑
        self.area_ocr_worker.signals.progress.connect(lambda p: self.progress_bar.setValue(p))
        self.area_ocr_worker.signals.error.connect(self.on_area_ocr_error)
        
        # ‰ΩøÁî®lambdaÊçïËé∑rectÂèÇÊï∞Ôºå‰º†ÈÄíÁªôÂõûË∞ÉÂáΩÊï∞
        self.area_ocr_worker.signals.finished.connect(
            lambda results: self.on_area_ocr_finished(results, rect, temp_path, x, y)
        )
        
        # ÊòæÁ§∫ËøõÂ∫¶Êù°
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        # ÂêØÂä®Á∫øÁ®ã
        self.thread_pool.start(self.area_ocr_worker)
        
    def on_area_ocr_error(self, error_msg: str):
        """Âå∫ÂüüOCRÈîôËØØÂ§ÑÁêÜ"""
        self.progress_bar.setVisible(False)
        QMessageBox.warning(self, "Âå∫ÂüüOCRËØÜÂà´ÈîôËØØ", error_msg)
        self.area_select_action.setChecked(False)
    
    def on_area_ocr_finished(self, results: List[dict], rect: QRectF, temp_path: str, offset_x: int, offset_y: int):
        """Âå∫ÂüüOCRÂÆåÊàêÂ§ÑÁêÜ"""
        self.progress_bar.setVisible(False)
        
        # Âà†Èô§‰∏¥Êó∂Êñá‰ª∂
        try:
            os.unlink(temp_path)
        except:
            pass
        
        # Â¶ÇÊûúÊ≤°ÊúâËØÜÂà´ÁªìÊûúÔºåÂàõÂª∫Á©∫ÁôΩÊ†áÊ≥®
        if not results:
            QMessageBox.information(self, "Âå∫ÂüüOCR", "ÈÄâ‰∏≠Âå∫ÂüüÊú™ËØÜÂà´Âà∞ÊñáÂ≠óÔºåÂ∞ÜÂàõÂª∫Á©∫ÁôΩÊ†áÊ≥®„ÄÇ")
            self.create_annotation_in_area(rect)
            self.area_select_action.setChecked(False)
            return
        
        # Ë∞ÉÊï¥ÁªìÊûúÂùêÊ†áÔºàÊ∑ªÂä†ÂÅèÁßªÈáèÔºâ
        for result in results:
            if 'bbox' in result:
                adjusted_bbox = []
                for point in result['bbox']:
                    adjusted_bbox.append([point[0] + offset_x, point[1] + offset_y])
                result['bbox'] = adjusted_bbox
            
            if 'center_x' in result and 'center_y' in result:
                result['center_x'] += offset_x
                result['center_y'] += offset_y
        
        # ÂàõÂª∫Â∫ïËâ≤ÊòæÁ§∫Âå∫Âüü - ‰∏éÂÖ®Â±ÄOCR‰∏ÄÊ†∑ÊòæÁ§∫ËØÜÂà´Âå∫Âüü
        for i, result in enumerate(results):
            self.create_ocr_bbox_item(result, i)
                
        # ‰∏∫ÊØè‰∏™OCRÁªìÊûúÂàõÂª∫Ê†áÊ≥®
        confidence_threshold = self.confidence_slider.value() / 100.0
        created_count = 0
        
        for result in results:
            if result.get('confidence', 0) >= confidence_threshold:
                # ‰øÆÊîπ‰∏∫‰ΩøÁî®Áõ∏ÂØπ‰∫éÂú∫ÊôØÁöÑÊ≠£Á°ÆÂùêÊ†áÂàõÂª∫Ê†áÊ≥®
                self.create_annotation_from_ocr_result(result)
                created_count += 1
        
        # Â∞ÜËØÜÂà´ÁªìÊûúÊ∑ªÂä†Âà∞ÂÖ®Â±ÄOCRÁªìÊûú‰∏≠Ôºå‰ª•‰æøÁ≠õÈÄâÂíåÁÆ°ÁêÜ
        self.ocr_results.extend(results)
        self.update_ocr_stats()
        
        if created_count > 0:
            QMessageBox.information(self, "Âå∫ÂüüOCRÂÆåÊàê", f"Âú®ÈÄâ‰∏≠Âå∫ÂüüÂÜÖËØÜÂà´Âá∫ {len(results)} ‰∏™ÊñáÊú¨ÔºåÂàõÂª∫‰∫Ü {created_count} ‰∏™Ê†áÊ≥®„ÄÇ")
            self.refresh_annotation_list()
        else:
            QMessageBox.information(self, "Âå∫ÂüüOCR", "ÈÄâ‰∏≠Âå∫ÂüüÁöÑËØÜÂà´ÁªìÊûúÊú™ËææÂà∞ÁΩÆ‰ø°Â∫¶ÈòàÂÄºÔºåÂ∞ÜÂàõÂª∫Á©∫ÁôΩÊ†áÊ≥®„ÄÇ")
            self.create_annotation_in_area(rect)
        
        self.area_select_action.setChecked(False)

    def delete_current_annotation(self):
        if self.current_annotation:
            # ËÆ∞ÂΩïÂΩìÂâçÊ†áÊ≥®‰ø°ÊÅØ
            annotation_id = self.current_annotation.annotation_id
            anchor_point = self.current_annotation.anchor_point
            annotation_text = self.current_annotation.text
            
            # 1. ‰øùÂ≠òÊâÄÊúâÊ†áÊ≥®ÁöÑÂàóË°®ÔºåÊåâIDÊéíÂ∫è
            sorted_annotations = sorted(self.annotations, key=lambda ann: ann.annotation_id)
            current_index = -1
            for i, ann in enumerate(sorted_annotations):
                if ann.annotation_id == annotation_id:
                    current_index = i
                    break
            
            # 2. Âà†Èô§Ê†áÊ≥®È°π
            self.delete_annotation(self.current_annotation)
            
            # 3. Êü•ÊâæÂπ∂Âà†Èô§ÂØπÂ∫îÁöÑOCRÁªìÊûúÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            if hasattr(self, 'ocr_results') and self.ocr_results:
                # Â∞ùËØïÈÄöËøáÂ§öÁßçÁ≠ñÁï•ÂåπÈÖçÊâæÂà∞ÂØπÂ∫îÁöÑOCRÁªìÊûú
                matching_ocr_indices = self._find_matching_ocr_results(anchor_point, annotation_text)
                
                # ‰ªéÂêéÂæÄÂâçÂà†Èô§ÂåπÈÖçÁöÑOCRÁªìÊûúÔºà‰ª•ÈÅøÂÖçÁ¥¢ÂºïÂèòÂåñÈóÆÈ¢òÔºâ
                if matching_ocr_indices:
                    for i in sorted(matching_ocr_indices, reverse=True):
                        if i < len(self.ocr_results):
                            self.ocr_results.pop(i)
                    
                    # ÈáçÊñ∞ÊòæÁ§∫OCRÁªìÊûú
                    self.clear_ocr_display()
                    self.display_ocr_results()
                    self.update_ocr_stats()
                    self.status_bar.showMessage(f"Â∑≤Âà†Èô§Ê†áÊ≥®È°πÂíå {len(matching_ocr_indices)} ‰∏™ÂØπÂ∫îÁöÑOCRÁªìÊûú", 3000)
                else:
                    self.status_bar.showMessage(f"Â∑≤Âà†Èô§Ê†áÊ≥®È°π", 3000)
            
            # 4. ÈÄâÊã©‰∏ã‰∏Ä‰∏™Ê†áÊ≥®È°π
            next_annotation = None
            
            # Ëé∑ÂèñÂà†Èô§ÂêéÁöÑÊ†áÊ≥®ÂàóË°®
            remaining_annotations = sorted(self.annotations, key=lambda ann: ann.annotation_id)
            
            # Â¶ÇÊûúÊúâÂà†Èô§ÂâçÁöÑÁ¥¢Âºï‰ø°ÊÅØ
            if current_index != -1 and remaining_annotations:
                # Â¶ÇÊûúÂΩìÂâçÁ¥¢ÂºïÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖÔºåÈÄâÊã©Áõ∏ÂêåÁ¥¢Âºï‰ΩçÁΩÆÁöÑÊ†áÊ≥®ÔºàÂõ†‰∏∫Â∑≤Âà†Èô§ÂΩìÂâçÈ°πÔºâ
                if current_index < len(remaining_annotations):
                    next_annotation = remaining_annotations[current_index]
                # Â¶ÇÊûúÁ¥¢ÂºïË∂ÖÂá∫ËåÉÂõ¥ÔºàÂà†Èô§ÁöÑÊòØÊúÄÂêé‰∏Ä‰∏™ÔºâÔºåÈÄâÊã©ÊúÄÂêé‰∏Ä‰∏™Ê†áÊ≥®
                elif remaining_annotations:
                    next_annotation = remaining_annotations[-1]
            
            # Â¶ÇÊûúÊâæÂà∞‰∫Ü‰∏ã‰∏Ä‰∏™Ê†áÊ≥®ÔºåÈÄâ‰∏≠ÂÆÉ
            if next_annotation:
                self.select_annotation_by_id(next_annotation.annotation_id)
            else:
                # Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞‰∏ã‰∏Ä‰∏™ÔºåÊ∏ÖÈô§ÂΩìÂâçÈÄâÊã©
                self.current_annotation = None
                self.property_editor.set_annotation(None, None)

    def _find_matching_ocr_results(self, anchor_point, annotation_text):
        """Â§öÁ≠ñÁï•ÂåπÈÖçOCRÁªìÊûú - ‰ºòÂåñÁâàÔºåÊõ¥‰∏•Ê†ºÁöÑÊ†áÂáÜÈÅøÂÖçËØØÂåπÈÖç"""
        matching_indices = []
        
        # ‰ªéÊñáÊú¨‰∏≠ÊèêÂèñÂéüÂßãOCRÊñáÊú¨ÔºàÂ¶ÇÊûúÊúâÔºâ
        original_ocr_text = None
        if annotation_text and "ÂéüÂßãÊñáÊú¨:" in annotation_text:
            parts = annotation_text.split("ÂéüÂßãÊñáÊú¨:")
            if len(parts) > 1:
                original_ocr_text = parts[1].strip()
        
        # Á°Æ‰øùÂè™ÊâæÂà∞ÊúÄÂåπÈÖçÁöÑ‰∏Ä‰∏™OCRÁªìÊûú
        best_match_index = -1
        best_match_score = float('inf')  # ÂàÜÊï∞Ë∂äÂ∞èË∂äÂåπÈÖç
        
        # ÈÅçÂéÜÊâÄÊúâOCRÁªìÊûú
        for i, ocr_result in enumerate(self.ocr_results):
            current_score = float('inf')  # ÂàùÂßãÂåñ‰∏∫ÊúÄÂ§ßÂÄº
            
            # Á≠ñÁï•1: Á≤æÁ°ÆÊñáÊú¨ÂåπÈÖç - Â¶ÇÊûúÊ†áÊ≥®‰∏≠ÂåÖÂê´ÂéüÂßãOCRÊñáÊú¨ÔºåÂàôÊ£ÄÊü•ÊòØÂê¶ÂÆåÂÖ®ÂåπÈÖç
            if original_ocr_text and 'text' in ocr_result:
                ocr_text = ocr_result['text']
                if ocr_text == original_ocr_text:
                    # ÂÆåÂÖ®ÂåπÈÖçÔºåËøôÊòØÊúÄ‰ºòÂÖàÁ∫ß
                    matching_indices = [i]
                    return matching_indices
                elif ocr_text.strip() == original_ocr_text.strip():
                    # Èô§‰∫ÜÁ©∫Ê†ºÂ§ñÂÆåÂÖ®ÂåπÈÖç
                    matching_indices = [i]
                    return matching_indices
            
            # Á≠ñÁï•2: ‰ΩçÁΩÆÂåπÈÖç - ÂΩìÊ≤°ÊúâÂÆåÂÖ®ÊñáÊú¨ÂåπÈÖçÊó∂ÔºåËÆ°ÁÆóÊúÄËøëÁöÑ‰∏Ä‰∏™
            if 'bbox' in ocr_result:
                bbox = ocr_result['bbox']
                if len(bbox) >= 4:
                    # ËÆ°ÁÆóOCRÊ°ÜÁöÑ‰∏≠ÂøÉÁÇπÂíåËæπÁïå
                    x_coords = [point[0] for point in bbox]
                    y_coords = [point[1] for point in bbox]
                    center_x = sum(x_coords) / len(bbox)
                    center_y = sum(y_coords) / len(bbox)
                    ocr_center = QPointF(center_x, center_y)
                    
                    # ËÆ°ÁÆóOCR‰∏≠ÂøÉÂà∞Ê†áÊ≥®ÈîöÁÇπÁöÑË∑ùÁ¶ª‰Ωú‰∏∫ÂàÜÊï∞
                    distance = ((ocr_center.x() - anchor_point.x())**2 + 
                                (ocr_center.y() - anchor_point.y())**2)**0.5
                    
                    # ‰πüËÄÉËôëÁâπÊÆäÁöÑÂè≥‰æß‰ΩçÁΩÆÂÖ≥Á≥ªÔºàÂä†ÊùÉÔºâ
                    right_edge = max(x_coords)
                    if anchor_point.x() > right_edge and abs(anchor_point.y() - center_y) < 20:
                        # Â¶ÇÊûú‰ΩçÁΩÆÂÖ≥Á≥ªÂæàÊòéÁ°ÆÔºàÊ†áÊ≥®Âú®OCRÂè≥‰æßÔºâÔºåË∑ùÁ¶ªÂàÜÊï∞ÂáèÂçä
                        distance *= 0.5
                    
                    # Êõ¥Êñ∞ÂæóÂàÜ
                    current_score = distance
            
            # Â¶ÇÊûúËøô‰∏™OCRÁªìÊûúÊØî‰πãÂâçÊâæÂà∞ÁöÑÊõ¥ÂåπÈÖçÔºåÊõ¥Êñ∞ÊúÄ‰Ω≥ÂåπÈÖç
            if current_score < best_match_score:
                best_match_score = current_score
                best_match_index = i
        
        # Âè™ÊúâÂΩìÊúÄ‰Ω≥ÂåπÈÖçÁöÑË∑ùÁ¶ªÂ∞è‰∫éÈòàÂÄºÊó∂ÊâçËøîÂõûÁªìÊûú
        # ‰ΩøÁî®Âõ∫ÂÆöÈòàÂÄº80ÂÉèÁ¥†ÔºåÊõ¥‰∏•Ê†ºÁöÑÂåπÈÖçÊ†áÂáÜ
        if best_match_index >= 0 and best_match_score < 80:
            matching_indices.append(best_match_index)
        
        return matching_indices

    def convert_pdf_to_images(self):
        """Â∞ÜPDFÊñá‰ª∂ÊâπÈáèËΩ¨Êç¢‰∏∫PNGÂõæÁâá"""
        if not HAS_OCR_SUPPORT:
            QMessageBox.warning(self, "ÂäüËÉΩÁº∫Â§±", "PDFËΩ¨Êç¢ÂäüËÉΩÈúÄË¶ÅPyMuPDFÊîØÊåÅ„ÄÇËØ∑ÂÆâË£ÖÊâÄÈúÄ‰æùËµñ„ÄÇ")
            return
            
        # ÊâìÂºÄÊñá‰ª∂ÈÄâÊã©ÂØπËØùÊ°ÜÔºå‰ªÖÈÄâÊã©PDFÊñá‰ª∂
        file_dialog = QFileDialog(self)
        file_dialog.setNameFilter("PDFÊñá‰ª∂ (*.pdf)")
        if not file_dialog.exec():
            return
            
        pdf_paths = file_dialog.selectedFiles()
        if not pdf_paths:
            return
            
        pdf_path = pdf_paths[0]
        pdf_filename = Path(pdf_path).name
        
        # Ëé∑ÂèñË¥®ÈáèËÆæÁΩÆ
        zoom_factor = PDF_QUALITY_OPTIONS.get(self.pdf_quality_combo.currentText(), 4.0)
        
        # ÊòæÁ§∫Ê≠£Âú®Â§ÑÁêÜÁöÑÊ∂àÊÅØ
        self.status_bar.showMessage(f"Ê≠£Âú®Â§ÑÁêÜPDF: {pdf_filename}...")
        
        # ÊòæÁ§∫ËøõÂ∫¶Êù°
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        try:
            # Ë∞ÉÁî®ËΩ¨Êç¢ÂáΩÊï∞
            png_paths, error = FileLoader.convert_pdf_to_pngs(pdf_path, zoom_factor=zoom_factor)
            
            # ÈöêËóèËøõÂ∫¶Êù°
            self.progress_bar.setVisible(False)
            
            if error:
                QMessageBox.warning(self, "ËΩ¨Êç¢Â§±Ë¥•", f"PDFËΩ¨Êç¢Â§±Ë¥•: {error}")
                self.status_bar.showMessage(f"‚ùå PDFËΩ¨Êç¢Â§±Ë¥•: {error}", 5000)
                return
                
            if not png_paths:
                QMessageBox.warning(self, "ËΩ¨Êç¢Â§±Ë¥•", "Êú™ËÉΩÁîüÊàêPNGÊñá‰ª∂„ÄÇ")
                self.status_bar.showMessage("‚ùå PDFËΩ¨Êç¢Â§±Ë¥•: Êú™ËÉΩÁîüÊàêPNGÊñá‰ª∂", 5000)
                return
                
            # ËΩ¨Êç¢ÊàêÂäüÔºåÊòæÁ§∫ÊàêÂäüÊ∂àÊÅØ
            success_message = f"PDFÊàêÂäüËΩ¨Êç¢‰∏∫{len(png_paths)}‰∏™PNGÊñá‰ª∂Ôºö\n\n"
            for i, path in enumerate(png_paths[:5]):  # Âè™ÊòæÁ§∫Ââç5‰∏™Êñá‰ª∂Ë∑ØÂæÑ
                success_message += f"{i+1}. {path}\n"
                
            if len(png_paths) > 5:
                success_message += f"\n... ‰ª•ÂèäÂè¶Â§ñ {len(png_paths) - 5} ‰∏™Êñá‰ª∂"
                
            # ËØ¢ÈóÆÊòØÂê¶ÊâìÂºÄÁ¨¨‰∏Ä‰∏™ÁîüÊàêÁöÑPNGÊñá‰ª∂
            result = QMessageBox.information(
                self, 
                "ËΩ¨Êç¢ÊàêÂäü", 
                success_message + "\n\nÊòØÂê¶ÊâìÂºÄÁ¨¨‰∏Ä‰∏™PNGÊñá‰ª∂Ôºü",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            
            if result == QMessageBox.Yes and png_paths:
                # Âä†ËΩΩÁ¨¨‰∏Ä‰∏™PNGÊñá‰ª∂
                self.load_file(png_paths[0])
            else:
                self.status_bar.showMessage(f"‚úÖ PDFËΩ¨Êç¢ÂÆåÊàê: {len(png_paths)}‰∏™Êñá‰ª∂", 5000)
                
        except Exception as e:
            self.progress_bar.setVisible(False)
            QMessageBox.critical(self, "ÈîôËØØ", f"ËΩ¨Êç¢ËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {str(e)}")
            self.status_bar.showMessage(f"‚ùå PDFËΩ¨Êç¢ÈîôËØØ: {str(e)}", 5000)